.class public Lr/m/c/a/c;
.super Ljava/lang/Object;
.source ""


# direct methods
.method public static a(Lq/i/b/f/e;)V
    .locals 1

    :try_start_0
    const-string v0, "{\n  ArcTan[x_, y_] :=\n      If[x == 0, If[y == 0, Indeterminate, If[y > 0, Pi / 2, -Pi / 2]], If[x > 0,\n        ArcTan[y / x], If[y >= 0, ArcTan[y / x] + Pi, ArcTan[y / x] - Pi]]]\n}\n"

    invoke-virtual {p0, v0}, Lq/i/b/f/e;->a(Ljava/lang/String;)Lq/i/b/m/b0;

    const-string v0, " \nFMin[x_, y_, z_, t_] := Minimize[x, y];\nFMin[x_, y_, z_, t_, u_] := Minimize[x, y];\nFMin[x_, y_] := Minimize[x, y];\n\nFMax[x_, y_, z_, t_] := Maximize[x, y];\nFMax[x_, y_, z_, t_, u_] := Maximize[x, y];\nFMax[x_, y_] := Maximize[x, y];\n\n \nTiRound[x_, y_] := Round[x, 10^(-y)];\nRemainder[x_, y_] := Mod[x, y];\n\n \nAngle[x_] := ArcTan[Re[x], Im[x]];\nAngleDegree[x_] := ArcTanDegree[Re[x], Im[x]];\nAngleGradian[x_] := ArcTanGradian[Re[x], Im[x]];\n\n \nTiRand[] := RandomReal[];\nTiRand[n_] := Table[RandomReal[], {n}];\nRandInt[x_, y_] := Block[{},\n  AssertIntegerArg[x];\n  AssertIntegerArg[y];\n  Return[x + RandomInteger[y - x]]\n];\nRandInt[x_, y_, z_] := Block[{},\n  AssertIntegerArg[x];\n  AssertIntegerArg[y];\n  AssertIntegerArg[z];\n  Return[x + RandomInteger[y - x, z]]\n];\nRandNorm[m_, s_, n_] := RandomVariate[NormalDistribution[m, s], n];\nRandNorm[m_, s_] := If[m <= 0, (m - 3 * s) + RandomReal[] * 6 * s, RandNorm[m, s, 1][[1]]];\nRandBin[n_, p_, m_] := Block[{},\n  AssertNumberArg[p];\n  If[Not[TrueQ[0 <= p && p <= 1]], Throw[ErrorProbabilityInterval]];\n  Return[RandomVariate[BinomialDistribution[n, p], m]];\n];\nRandBin[n_, p_] := RandBin[n, p, 1][[1]];\nRandIntNoRep[x_, y_] := RandomSample[Range[x, y]];\n\n \nRadianToDegree[x_] := x * 180 / Pi;\nRadianToGradian[x_] := x * 200 / Pi;\nDegreeToRadian[x_] := x * Pi / 180;\nDegreeToGradian[x_] := x / 9 * 10;\nGradianToRadian[x_] := x * Pi / 200;\nGradianToDegree[x_] := x / 10 * 9;\n\nRectToPolarR[x_, y_] := Part[ToPolarCoordinates[{x, y}], 1];\nRectToPolarTheta[x_, y_] := Part[ToPolarCoordinates[{x, y}], 2];\nRectToPolarThetaDegree[x_, y_] := RadianToDegree[Part[ToPolarCoordinates[{x, y}], 2]];\nRectToPolarThetaGradian[x_, y_] := RadianToGradian[Part[ToPolarCoordinates[{x, y}], 2]];\n\nPolarToRectX[r_, t_] := Part[FromPolarCoordinates[{r, t}], 1];\nPolarToRectXDegree[r_, t_] := Part[FromPolarCoordinates[{r, DegreeToRadian[t]}], 1];\nPolarToRectXGradian[r_, t_] := Part[FromPolarCoordinates[{r, GradianToRadian[t]}], 1];\n\nPolarToRectY[r_, t_] := Part[FromPolarCoordinates[{r, t}], 2];\nPolarToRectYDegree[r_, t_] := Part[FromPolarCoordinates[{r, DegreeToRadian[t]}], 2];\nPolarToRectYGradian[r_, t_] := Part[FromPolarCoordinates[{r, GradianToRadian[t]}], 2];\n\n\n \nRandM[x_, y_] := Table[Table[-9 + RandomInteger[18], {b, 1, y}], {a, 1, x}];\nRREF[x_] := If[MatrixQ[x], RowReduce[x], Throw[ErrorDataType]];\n\nCumSum[m_] := If[Or[ListQ[m], MatrixQ[m]], Accumulate[m], Throw[ErrorDataType]];\n\nRowSwap[m_, a_, b_] :=\n    If[And[MatrixQ[m], IntegerQ[a], IntegerQ[b]],\n      ReplacePart[m, {{a} -> Part[m, b], {b} -> Part[m, a] }],\n      Throw[ErrorDataType]];\nRowPlus[m_, a_, b_] :=\n    If[And[MatrixQ[m], IntegerQ[a], IntegerQ[b]],\n      ReplacePart[m, {{b} -> Part[m, a] + Part[m, b]}],\n      Throw[ErrorDataType]];\nRowMultiply[v_, m_, i_] :=\n    If[And[MatrixQ[m], IntegerQ[i]],\n      ReplacePart[m, {{i} -> Part[m, i] * v}],\n      Throw[ErrorDataType]];\nRowMultiplyPlus[v_, m_, a_, b_] :=\n    If[And[MatrixQ[m], IntegerQ[a], IntegerQ[b]],\n      ReplacePart[m, {{b} -> Part[m, a] * v + Part[m, b]}], Throw[ErrorDataType]];\n \nDim[m_] := If[MatrixQ[m], Dimensions[m], If[ListQ[m], Length[m], Throw[ErrorDataType]]];\n \n \nFill[x_, m_] := If[MatrixQ[m],\n  Table[ Table[x, Part[Dimensions[m], 2]], Part[Dimensions[m], 1]],\n  If[ListQ[m], Table[x, Length[m]], Throw[ErrorDataType]]];\n\n \nListSequence[x_, y_Symbol, z_, t_] := Table[x, {y, z, t}];\nListSequence[x_, y_Symbol, z_, t_, u_] := Table[x, {y, z, t, u}];\n\n \n \n \n \n \nAugment[x_, y_] :=\n    If[And[MatrixQ[x], MatrixQ[y], Dimensions[x][[1]] == Dimensions[y][[1]]],\n      Table[Join[x[[i]], y[[i]]], {i, 1, Dimensions[x][[1]]}],\n      If[And[ListQ[x], ListQ[y]], Join[x, y], Throw[ErrorDataType]]];\n\nMinList[x_] := Min[x];\nMinList[x_, y_] :=\n    If[Or[ListQ[x], ListQ[y]],\n      If[And[ListQ[x], ListQ[y]],\n        If[Unequal[Length[x], Length[y]],\n          Throw[ErrorDimMismatch],\n          MapThread[Min, {x, y}]],\n        If[ListQ[x],\n          MapThread[Min, {x, Table[y, {$tmp, Length[x]}]}],\n          MapThread[Min, {Table[x, {$tmp, Length[y]}], y}]]],\n      Min[x, y]];\nMaxList[x_] := Max[x];\nMaxList[x_, y_] :=\n    If[Or[ListQ[x], ListQ[y]],\n      If[And[ListQ[x], ListQ[y]],\n        If[Unequal[Length[x], Length[y]],\n          Throw[ErrorDimMismatch],\n          MapThread[Max, {x, y}]],\n        If[ListQ[x],\n          MapThread[Max, {x, Table[y, {$tmp, Length[x]}]}],\n          MapThread[Max, {Table[x, {$tmp, Length[y]}], y}]]],\n      Max[x, y]];\n \nDeltaList[m_] :=\n    If[ListQ[m], Table[ Part[m, $i] - Part[m, $i - 1], {$i, 2, Length[m], 1}], Throw[ErrorDataType]];\nNumericListQ[x_] := AllTrue[Map[NumericQ, x], TrueQ];\nAssertNotEmptyList[x_] := If[ListQ[x], If[Length[x] == 0, Throw[ErrorDataEmpty], x], Throw[ErrorArgNotList]];\nAssertListArg[x_] := If[ListQ[x], x, Throw[ErrorArgNotList]];\nAssertSameDimensions[x_, y_] := If[Not[Dimensions[x] == Dimensions[y]], Throw[ErrorDimMismatch]];\nAssertNonNegativeList[x_] := If[AnyTrue[x, Negative], Throw[ErrorDataType]];\nAssertNumericList[x_] := If[Not[NumericListQ[x]], Throw[ErrorDataType]];\nAssertMatrixArg[x_] := If[Not[MatrixQ[x]], Throw[ErrorDataType], x];\nAssertNumberArg[x_] := If[Not[NumberQ[x]], Throw[ErrorDataType], x];\nAssertIntegerArg[x_] := If[Not[IntegerQ[x]], Throw[ErrorArgNotInteger], x];\nAssertFuzzyIntegerArg[x_] := If[TrueQ[x == Round[x]], Round[x],\n  Print[\"Error: AssertFuzzyIntegerArg x = \", x]; Throw[ErrorArgNotInteger]];\nAssertRealNumberList[x_] := (AssertListArg[x]; If[Not[AllTrue[x, RealNumberQ]], Throw[ErrorDataType]]);\nIsTrue[x_] := If[BooleanQ[x], x, If[x == 0, False, True]];\n \n \n \nExpandList[x_, y_] :=\n    If[ListQ[x],\n      If[Length[x] == 0,\n        Throw[ErrorDataEmpty],\n        If[ListQ[y],\n          If[AllTrue[Map[Rationalize, y], IntegerQ],\n            If[Dimensions[x] == Dimensions[y],\n              Flatten[Table[Table[x[[i]], y[[i]]], {i, 1, Length[x]}], 1],\n              Throw[ErrorDimMismatch]\n            ],\n            Throw[ErrorNonIntFreq]\n          ],\n          If[y == 1, x, Throw[ErrorDataType]]\n        ]\n      ],\n      Throw[ErrorDataType]\n    ];\n\n \n \n\n \nTiWeightedQuantile[xi_, wi_, prob_] := Block[{$x, $w, $ord, $low, $high, $cumSumW},\n   \n  $ord = Ordering[xi];\n  $x = xi[[$ord]];\n  $w = wi[[$ord]];\n  $cumSumW = Accumulate[$w] / Total[$w];\n   \n   \n   \n   \n   \n  $low = If[Min[$cumSumW] > prob, 1, Max[Position[$cumSumW, _?(# <= prob &)]]];\n   \n  $high = If[Max[$cumSumW] < prob, Length[$x], Min[Position[$cumSumW, _?(# > prob &)]]];\n   \n   \n   \n   \n   \n  If[$cumSumW[[$low]] < prob,\n    $x[[$high]],\n     \n    ($x[[$low]] + $x[[$high]]) / 2  \n  ]\n];\n\n \nTiOneVarStats[x_, fr_] := Block[{freq, $mean, $nn, $sumx, $intList, $noWeighted, $sortedX},\n  freq = If[TrueQ[fr == 1], Table[1, Length[x]], fr];\n\n  AssertNotEmptyList[x];\n  AssertNotEmptyList[freq];\n  AssertSameDimensions[x, freq];\n  AssertNumericList[x];\n  AssertRealNumberList[x];\n  AssertNumericList[freq];\n  AssertRealNumberList[freq];\n  AssertNonNegativeList[freq];\n\n  $nn = Total[freq];\n  If[PossibleZeroQ[$nn], Throw[ErrorDataEmpty]];\n  $sumx = Total[x * freq];\n  $mean = $sumx / Total[freq];\n  $intList = AllTrue[Map[Rationalize, freq], IntegerQ];\n  $noWeighted = AllTrue[freq, # == 1 &];\n  $sortedX = Sort[x];\n  Return[\n    { $mean,\n       $sumx,\n       Total[Power[x, 2] * freq],\n       If[$intList, Sqrt[Total[Power[x - $mean, 2] * freq] / ($nn - 1)], Indeterminate],\n       Sqrt[Total[Power[x - $mean, 2] * freq] / $nn],\n       $nn,\n       Min[x],\n       \n      If[$noWeighted,\n        Median[Take[$sortedX, Floor[Length[$sortedX] / 2]]],\n        TiWeightedQuantile[x, freq, 1 / 4]],\n       \n      If[$noWeighted,\n        Median[$sortedX],\n        TiWeightedQuantile[x, freq, 1 / 2]],\n       \n      If[$noWeighted,\n        Median[Take[$sortedX, -Floor[Length[$sortedX] / 2]]],\n        TiWeightedQuantile[x, freq, 3 / 4]],\n       Max[x]}]\n];\nTiOneVarStats[x_] := TiOneVarStats[x, 1];\n\nTiTwoVarStats[x_, y_, fr_] := Block[{freq, $nn, $intList, $meanX, $meanY, $sumX, $sumY},\n  freq = If[TrueQ[fr == 1], Table[1, Length[x]], fr];\n  AssertNotEmptyList[x];\n  AssertNotEmptyList[y];\n  AssertNotEmptyList[freq];\n  AssertSameDimensions[x, y];\n  AssertSameDimensions[x, freq];\n  AssertNumericList[x];\n  AssertNumericList[y];\n  AssertNumericList[freq];\n  AssertNonNegativeList[freq];\n\n  $nn = Total[freq];\n  If[PossibleZeroQ[$nn], Throw[ErrorDataEmpty]];\n  $intList = AllTrue[Map[Rationalize, freq], IntegerQ];\n  $sumX = Total[x * freq];\n  $sumY = Total[y * freq];\n  $meanX = $sumX / $nn;\n  $meanY = $sumY / $nn;\n  Return[{\n      $meanX,\n      $sumX,\n     Total[Power[x, 2] * freq],\n     If[$intList, Sqrt[Total[Power[x - $meanX, 2] * freq] / ($nn - 1)], Indeterminate],\n     Sqrt[Total[Power[x - $meanX, 2] * freq] / $nn],\n     $nn,\n      $meanY,\n      $sumY,\n     Total[Power[y, 2] * freq],\n     If[$intList, Sqrt[Total[Power[y - $meanY, 2] * freq] / ($nn - 1)], Indeterminate],\n     Sqrt[Total[Power[y - $meanY, 2] * freq] / $nn],\n     Total[x * y * freq],\n     Min[x], Max[x], Min[y], Max[y]}]\n];\nTiTwoVarStats[x_, y_] := TiTwoVarStats[x, y, 1];\n\nTiMean[x_] := Mean[x];\nTiMean[x_, y_] := Mean[ExpandList[x, y]];\n\nTiMedian[x_] := Median[x];\nTiMedian[x_, y_] := Median[ExpandList[x, y]];\n\nTiSum[x_] := TiSum[x, 1, Length[x]];\nTiSum[x_, start_, end_] := Block[{},\n  AssertNotEmptyList[x];\n  If[Not[TrueQ[start >= 1 && end <= Length[x] && start <= end]], Throw[ErrorInvalidDim]];\n  Return[Total[x[[start ;; end]]]]\n];\n\nTiProd[x_] := TiProd[x, 1, Length[x]];\nTiProd[x_, start_, end_] := Block[{},\n  AssertNotEmptyList[x];\n  If[Not[TrueQ[start >= 1 && end <= Length[x] && start <= end]], Throw[ErrorInvalidDim]];\n  Return[Product[x[[$i]], {$i, start, end}]]\n];\n\nTiStdDev[x_] := StandardDeviation[x];\nTiStdDev[x_, y_] := StandardDeviation[ExpandList[x, y]];\n\nTiVariance[x_] := Variance[x];\nTiVariance[x_, y_] := Variance[ExpandList[x, y]];\n\n \nNormalPDF[x_, m_, s_] := PDF[NormalDistribution[m, s], x];\nNormalPDF[x_] := NormalPDF[x, 0, 1];\n\n \nNormalCDF[x_, y_, m_, s_] := CDF[NormalDistribution[m, s], y] - CDF[NormalDistribution[m, s], x];\nNormalCDF[x_, y_] := NormalCDF[x, y, 0, 1];\n\n \nInvNorm[a_, m_, s_] := InverseCDF[NormalDistribution[m, s], a];\nInvNorm[a_] := InvNorm[a, 0, 1];\n\n \nInvT[a_, d_] := InverseCDF[StudentTDistribution[d], a];\n \nTPDF[x_, d_] := PDF[StudentTDistribution[d], x];\n \nTCDF[a_, b_, d_] := CDF[StudentTDistribution[d], b] - CDF[StudentTDistribution[d], a];\n\nChiSquarePDF[x_, d_] := PDF[ChiSquareDistribution[d], x];\nChiSquareCDF[a_, b_, d_] := CDF[ChiSquareDistribution[d], b] - CDF[ChiSquareDistribution[d], a];\n\nFPDF[x_, n_, d_] := PDF[FRatioDistribution[n, d], x];\nFCDF[a_, b_, n_, d_] := CDF[FRatioDistribution[n, d], b] - CDF[FRatioDistribution[n, d], a];\n\n \nBinomPDF[n_, p_, x_] := PDF[BinomialDistribution[n, p], x];\nBinomPDF[n_, p_] := PDF[BinomialDistribution[n, p], Range[0, n]];\n \nBinomCDF[n_, p_, x_] := CDF[BinomialDistribution[n, p], x];\nBinomCDF[n_, p_] := CDF[BinomialDistribution[n, p], Range[0, n]];\n \nPoissonPDF[m_, x_] := PDF[PoissonDistribution[m], x];\nPoissonCDF[m_, x_] := CDF[PoissonDistribution[m], x];\n \nGeometPDF[p_, x_] := PDF[GeometricDistribution[p], x - 1];\nGeometCDF[p_, x_] := CDF[GeometricDistribution[p], x - 1];\n\n \n \n \n \nMultipleCorrelation[y_, yhat_] :=\n    Sqrt[1 - Total[Power[y - yhat, 2]] / Total[Power[y - Mean[y], 2]]];\n\n \nGetRegDataError[x_, y_, z_] := Block[{},\n  If[Not[AllTrue[{x, y, z}, ListQ]], Throw[ErrorArgNotList]];\n  If[Or[Length[x] == 0, Length[y] == 0, Length[z] == 0, AllTrue[z, PossibleZeroQ]], Throw[ErrorDataEmpty]];\n  If[Not[Equal[Length[x], Length[y], Length[z]]], Throw[ErrorDimMismatch]];\n  If[Not[And[NumericListQ[x], NumericListQ[y], NumericListQ[z]]], Throw[ErrorDataType]];\n  Return[0]\n];\nGetRegDataError[x_, y_] := Block[{},\n  If[Not[And[ListQ[x], ListQ[y]]], Throw[ErrorArgNotList]];\n  If[Or[Length[x] == 0, Length[y] == 0], Throw[ErrorDataEmpty]];\n  If[Not[Equal[Length[x], Length[y]]], Throw[ErrorDimMismatch]];\n  If[Not[And[NumericListQ[x], NumericListQ[y]]], Throw[ErrorDataType]];\n  Return[0];\n];\nIsRegDataValid[x_, y_, z_] := PossibleZeroQ[GetRegDataError[x, y, z]];\nIsRegDataValid[x_, y_] := PossibleZeroQ[GetRegDataError[x, y]];\nCheckDimAtLeast[x_, n_] :=\n    If[ListQ[x] && IntegerQ[n],\n      If[Length[x] < n, Throw[ErrorInvalidDim], x],\n      Throw[ErrorDataType]];\nCheckNonZeroNumber[x_] :=\n    If[NumericQ[x],\n      If[TrueQ[PossibleZeroQ[x]], Throw[ErrorDomain], x],\n      Throw[ErrorDataType]];\n\nTiListPoints[x_, y_] := Table[{Part[x, i], Part[y, i]}, {i, 1, Length[x]}];\n\n \n \n \n \nTiLinReg[x_, y_, z_, t_] := TiLinReg[ExpandList[x, z], ExpandList[y, z]];\nTiLinReg[x_, y_, z_] := If[ListQ[z], TiLinReg[ExpandList[x, z], ExpandList[y, z]], TiLinReg[x, y]];\nTiLinReg[x_, y_] :=\n    If[IsRegDataValid[x, y],\n      Block[{a, b, $coeff, $r, $yReal, $meanX, $meanY, Sxy, Sxx, Syy},\n        $meanX = Mean[x] // N;\n        $meanY = Mean[y] // N;\n        Sxx = Total[Power[x - $meanX, 2]] // N;\n        Syy = Total[Power[y - $meanY, 2]] // N;\n        Sxy = Total[(x - $meanX) * (y - $meanY)] // N;\n        a = Sxy / Sxx;\n        b = $meanY - a * $meanX;\n        $yReal = a * x + b;\n        $r = Sxy / (Sqrt[Sxx] * Sqrt[Syy]);\n        Return[{ a,  b,  $r,   Power[$r, 2],   y - $yReal}]\n      ],\n      GetRegDataError[x, y]\n    ];\n\n \n \n \n \nTiQuadReg[x_, y_, z_, t_] := TiQuadReg[ExpandList[x, z], ExpandList[y, z]];\nTiQuadReg[x_, y_, z_] := If[ListQ[z], TiQuadReg[ExpandList[x, z], ExpandList[y, z]], TiQuadReg[x, y]];\nTiQuadReg[x_, y_] :=\n    If[IsRegDataValid[x, y],\n      Block[{a, b, c, v, $R2, $yReal, $meanX, $meanY, $meanX2, $x2, Sxx, Sxy, Sxx2, Sx2x2, Sx2y},\n        CheckDimAtLeast[x, 3];\n        CheckDimAtLeast[y, 3];\n        $meanX = Mean[x] // N;\n        $meanY = Mean[y] // N;\n        $x2 = Power[x, 2] // N;\n        $meanX2 = Mean[$x2] // N;\n        Print[\"MeanX: \", $meanX];\n        Sxx = Total[Power[x - $meanX, 2]];\n        Sxy = Total[(x - $meanX) * (y - $meanY)];\n        Sxx2 = Total[(x - $meanX) * ($x2 - $meanX2)];\n        Sx2x2 = Total[Power[$x2 - $meanX2, 2]];\n        Sx2y = Total[($x2 - $meanX) * (y - $meanY)];\n        b = (Sxy * Sx2x2 - Sx2y * Sxx2) / (Sxx * Sx2x2 - Sxx2 ^ 2);\n        c = (Sx2y * Sxx - Sxy * Sxx2) / (Sxx * Sx2x2 - Sxx2 ^2);\n        a = $meanY - b * $meanX - c * $meanX2;\n        $yReal = c * $x2 + b * x + a;\n        $R2 = 1 - Total[Power[y - $yReal, 2]] / Total[Power[y - $meanY, 2]];\n        Return[{c, b, a, $R2, y - $yReal}]\n      ],\n      GetRegDataError[x, y]\n    ];\n\n \nTiCubicReg[x_, y_, z_, t_] := TiCubicReg[ExpandList[x, z], ExpandList[y, z]];\nTiCubicReg[x_, y_, z_] := If[ListQ[z], TiCubicReg[ExpandList[x, z], ExpandList[y, z]], TiCubicReg[x, y]];\nTiCubicReg[x_, y_] :=\n    If[IsRegDataValid[x, y],\n      Block[{a, b, c, d, v, $r, $coefficients, $yReal, $poly},\n        CheckDimAtLeast[x, 4];\n        CheckDimAtLeast[y, 4];\n        $poly = Fit[TiListPoints[x, y], 3, v];\n        $coefficients = CoefficientList[$poly, v];\n         \n        d = If[Length[$coefficients] >= 1, Part[$coefficients, 1], 0];\n        c = If[Length[$coefficients] >= 2, Part[$coefficients, 2], 0];\n        b = If[Length[$coefficients] >= 3, Part[$coefficients, 3], 0];\n        a = If[Length[$coefficients] >= 4, Part[$coefficients, 4], 0];\n        $yReal = ReplaceAll[$poly, {v -> x}];\n        $r = MultipleCorrelation[y, $yReal];\n        Return[{a, b, c, d, Power[$r, 2], y - $yReal}]\n      ],\n      GetRegDataError[x, y]\n    ];\n\n \nTiQuartReg[x_, y_, z_, t_] := TiQuartReg[ExpandList[x, z], ExpandList[y, z]];\nTiQuartReg[x_, y_, z_] := If[ListQ[z], TiQuartReg[ExpandList[x, z], ExpandList[y, z]], TiQuartReg[x, y]];\nTiQuartReg[x_, y_] :=\n    If[IsRegDataValid[x, y],\n      Block[{a, b, c, d, e, v, $poly, $coefficients, $r, $yReal},\n        CheckDimAtLeast[x, 5];\n        CheckDimAtLeast[y, 5];\n        $poly = Fit[TiListPoints[x, y], 4, v];\n        $coefficients = CoefficientList[$poly, v];\n         \n        e = If[Length[$coefficients] >= 1, Part[$coefficients, 1], 0];\n        d = If[Length[$coefficients] >= 2, Part[$coefficients, 2], 0];\n        c = If[Length[$coefficients] >= 3, Part[$coefficients, 3], 0];\n        b = If[Length[$coefficients] >= 4, Part[$coefficients, 4], 0];\n        a = If[Length[$coefficients] >= 5, Part[$coefficients, 5], 0];\n        $yReal = ReplaceAll[$poly, {v -> x}];\n        $r = MultipleCorrelation[y, $yReal];\n        Return[{a, b, c, d, e, Power[$r, 2], y - $yReal}]\n      ],\n      GetRegDataError[x, y]\n    ];\n\n \n \nTiLinReg2[x_, y_, z_, t_] := TiLinReg2[ExpandList[x, z], ExpandList[y, z]];\nTiLinReg2[x_, y_, z_] := If[ListQ[z], TiLinReg2[ExpandList[x, z], ExpandList[y, z]], TiLinReg2[x, y]];\nTiLinReg2[x_, y_] :=\n    If[IsRegDataValid[x, y],\n      Block[{a, b, $coeff, $r, $yReal, $meanX, $meanY, Sxy, Sxx, Syy},\n        $meanX = Mean[x] // N;\n        $meanY = Mean[y] // N;\n        Sxx = Total[Power[x - $meanX, 2]] // N;\n        Syy = Total[Power[y - $meanY, 2]] // N;\n        Sxy = Total[(x - $meanX) * (y - $meanY)] // N;\n        b = Sxy / Sxx;\n        a = $meanY - b * $meanX;\n        $yReal = a + b * x;\n        $r = Sxy / (Sqrt[Sxx] * Sqrt[Syy]);\n        Return[{ a,  b,  $r,   Power[$r, 2],   y - $yReal}]\n      ],\n      GetRegDataError[x, y]\n    ];\n\n \n \nTiLnReg[x_, y_, z_, t_] := TiLnReg[ExpandList[x, z], ExpandList[y, z]];\nTiLnReg[x_, y_, z_] := If[ListQ[z], TiLnReg[ExpandList[x, z], ExpandList[y, z]], TiLnReg[x, y]];\nTiLnReg[x_, y_] :=\n    If[IsRegDataValid[x, y],\n      Block[{a, b, Sxx, Sxy, Syy, $r, $yReal, $logx, $meanLogX, $meanY},\n        $logx = Log[x] // N;\n        $meanLogX = Mean[$logx];\n        $meanY = Mean[y] // N;\n        Sxx = N[ Total[ Power[ $logx - $meanLogX , 2 ] ] ];\n        Syy = N[ Total[ Power[ y - $meanY , 2] ] ];\n        Sxy = N[ Total[ ($logx - $meanLogX ) * (y - $meanY) ] ];\n        b = Sxy / Sxx;\n        a = $meanY - b * $meanLogX;\n        $yReal = a + b * $logx;\n        $r = Sxy / (Sqrt[Sxx] * Sqrt[Syy]);\n        Join[ {a, b}, { $r, Power[$r, 2], y - $yReal}]\n      ],\n      GetRegDataError[x, y]\n    ];\n\n \n \nTiExpReg[x_, y_, z_, t_] := TiExpReg[ExpandList[x, z], ExpandList[y, z]];\nTiExpReg[x_, y_, z_] := If[ListQ[z], TiExpReg[ExpandList[x, z], ExpandList[y, z]], TiExpReg[x, y]];\nTiExpReg[x_, y_] :=\n    If[IsRegDataValid[x, y],\n      Block[{a, b, Sxx, Syy, Sxy, $r, $yReal, $meanX, $logY, $meanLogY},\n        $meanX = Mean[x] // N;\n        $logY = Log[y] // N;\n        $meanLogY = Mean[$logY];\n        Sxx = N[ Total[Power[x - $meanX, 2]] ];\n        Syy = N[ Total[Power[$logY - $meanLogY, 2]] ];\n        Sxy = N[ Total[ (x - $meanX) * ($logY - $meanLogY) ] ];\n        b = N[ Exp[Sxy / Sxx] ];\n        a = N[ Exp[$meanLogY - $meanX * Log[b]] ];\n        $yReal = a * b ^ x;\n        $r = Sxy / (Sqrt[Sxx] * Sqrt[Syy]);\n        Join[ {a, b}, { $r, Power[$r, 2], y - $yReal}]\n      ],\n      GetRegDataError[x, y]\n    ];\n\n\n \n \nTiEulerExpReg[x_, y_, z_, t_] := TiEulerExpReg[ExpandList[x, z], ExpandList[y, z]];\nTiEulerExpReg[x_, y_, z_] := If[ListQ[z], TiEulerExpReg[ExpandList[x, z], ExpandList[y, z]], TiEulerExpReg[x, y]];\nTiEulerExpReg[x_, y_] :=\n    If[IsRegDataValid[x, y],\n      Block[{a, b, Sxx, Syy, Sxy, $r, $yReal, $meanX, $logY, $meanLogY},\n        $meanX = Mean[x] // N;\n        $logY = Log[y] // N;\n        $meanLogY = Mean[$logY];\n        Sxx = N[ Total[Power[ x - $meanX , 2]] ];\n        Syy = N[ Total[Power[ $logY - $meanLogY, 2]] ];\n        Sxy = N[ Total[ (x - $meanX) * ($logY - $meanLogY) ] ];\n        b = N[ Sxy / Sxx ];\n        a = N[ Exp[$meanLogY - b * $meanX ] ];\n        $yReal = a * E ^ (b * x);\n        $r = Sxy / (Sqrt[Sxx] * Sqrt[Syy]);\n        Join[ {a, b}, { $r, Power[$r, 2], y - $yReal}]\n      ],\n      GetRegDataError[x, y]\n    ];\n\n\n \n \nTiPwrReg[x_, y_, z_, t_] := TiPwrReg[ExpandList[x, z], ExpandList[y, z]];\nTiPwrReg[x_, y_, z_] := If[ListQ[z], TiPwrReg[ExpandList[x, z], ExpandList[y, z]], TiPwrReg[x, y]];\nTiPwrReg[x_, y_] :=\n    If[IsRegDataValid[x, y],\n      Block[{a, b, $r, $yHat, $n, Sxx, Syy, Sxy, $logX, $logY, $meanLogX, $meanLogY},\n        $n = Length[x];\n        $logX = Log[x] // N;\n        $logY = Log[y] // N;\n        $meanLogX = Mean[$logX];\n        $meanLogY = Mean[$logY];\n        b = N[($n * Total[$logX * $logY] - Total[$logX] * Total[$logY])\n            / ($n * Total[$logX ^ 2] - Total[$logX] ^ 2)];\n        a = N[Exp[1 / $n * Total[$logY] - b / $n * Total[$logX]]];\n        $yHat = a * x ^ b;\n        Sxx = N[ Total[Power[$logX - $meanLogX, 2]] ];\n        Syy = N[ Total[Power[$logY - $meanLogY, 2]] ];\n        Sxy = N[ Total[($logX - $meanLogX) * ($logY - $meanLogY)] ];\n        $r = Sxy / (Sqrt[Sxx] * Sqrt[Syy]);\n        Return[ {a, b, $r, Power[$r, 2], y - $yHat}]\n      ],\n      GetRegDataError[x, y]\n    ];\n\n\n \n \nTiInverseReg[x_, y_, z_, t_] := TiInverseReg[ExpandList[x, z], ExpandList[y, z]];\nTiInverseReg[x_, y_, z_] := If[ListQ[z], TiInverseReg[ExpandList[x, z], ExpandList[y, z]], TiInverseReg[x, y]];\nTiInverseReg[x_, y_] :=\n    If[IsRegDataValid[x, y],\n      Block[{a, b, $r, $yHat, $n, Sxx, Syy, Sxy, invX, $meanY, $meanInvX},\n        $meanY = Mean[y] // N;\n        invX = N[ 1 / x ];\n        $meanInvX = Mean[invX];\n        Sxx = N[ Total[Power[invX - $meanInvX, 2]] ];\n        Syy = N[ Total[Power[y - $meanY, 2]] ];\n        Sxy = N[ Total[(invX - $meanInvX) * (y - $meanY)] ];\n        b = Sxy / Sxx;\n        a = $meanY - b * $meanInvX;\n        $yHat = a + b / x;\n        $r = Sxy / (Sqrt[Sxx] * Sqrt[Syy]);\n        Join[ {a, b}, { $r, Power[$r, 2], y - $yHat}]\n      ],\n      GetRegDataError[x, y]\n    ];\n\n \nTiLogisticReg[x_, y_, z_, t_] := TiLogisticReg[ExpandList[x, z], ExpandList[y, z]];\nTiLogisticReg[x_, y_, z_] := If[ListQ[z],\n  TiLogisticReg[ExpandList[x, z], ExpandList[y, z]],\n  TiLogisticReg[x, y]];\nTiLogisticReg[x_, y_] :=\n    If[IsRegDataValid[x, y],\n      Block[{a, b, c, v, a0, b0, c0, dm, dat, $coeff, $yReal, $r},\n        CheckDimAtLeast[x, 3];\n        CheckDimAtLeast[y, 3];\n        Clear[a, b, c, v];\n        dat = Transpose[{x, y}];\n         \n        c0 = Max[y];\n        dm = DeleteCases[dat, {_, c_ /; c == c0 || PossibleZeroQ[c]}];  \n         \n        Clear[a, b, c, v];\n        {a0, b0} = {Exp[-a], b} /.\n            FindFit[Transpose[{dm[[All, 1]], Log[dm[[All, 2]] / (c0 - dm[[All, 2]])]}],\n              a + b * v, {a, b}, v];\n        $coeff = FindFit[dat, c / (1 + a * Exp[-b * v]), {{a, a0}, {b, b0}, {c, c0}}, v];\n        $yReal = ReplaceAll[c / (1 + a * Exp[-b * v]), Join[$coeff, {v -> x}]];\n        $r = MultipleCorrelation[y, $yReal];\n        Join[ $coeff[[All, 2]], { Power[$r, 2], y - $yReal}]\n      ],\n      GetRegDataError[x, y]\n    ];\n\n \n \n \n \nTiSinReg[x_, y_] :=\n    If[IsRegDataValid[x, y],\n      Block[{iYMin, iYMax, sinRegPeriod},\n        CheckDimAtLeast[x, 4];\n        CheckDimAtLeast[y, 4];\n        iYMin = First[First[Position[y, Min[y]]]];\n        iYMax = First[First[Position[y, Max[y]]]];\n        sinRegPeriod = Abs[x[[iYMin]] - x[[iYMax]]] * 2;\n        If[Not[NumericQ[sinRegPeriod]], Throw[ErrorDataType]];\n        If[sinRegPeriod == 0, sinRegPeriod = Pi];\n        Return[TiSinReg[x, y, sinRegPeriod, Pi]]\n      ],\n      GetRegDataError[x, y]\n    ];\nTiSinReg[x_, y_, arg3_] :=\n    If[NumericQ[arg3], TiSinReg[x, y, arg3, Pi], TiSinReg[x, y]];\nTiSinReg[x_, y_, period_, sym_] :=\n    If[IsRegDataValid[x, y],\n      Block[{a, b, c, d, v, b0, $coeff, $yReal, $r, maxV, minV},\n        CheckDimAtLeast[x, 4];\n        CheckDimAtLeast[y, 4];\n        CheckNonZeroNumber[period];\n        Clear[a, b, c, d, v];\n        maxV = Max[y];\n        minV = Min[y];\n        b0 = 2 * Pi / period;\n        $coeff = FindFit[N[TiListPoints[x, y]], a * Sin[b * v + c] + d,\n          {{a, 1 / 2 * (maxV - minV)}, {b, b0}, c, {d, 1 / 2 * (maxV + minV)}}, v];\n        $yReal = ReplaceAll[a * Sin[b * v + c] + d, Join[$coeff, {v -> x}]];\n        $r = MultipleCorrelation[y, $yReal];\n        Join[ $coeff[[All, 2]], { Power[$r, 2], y - $yReal}]\n      ],\n      GetRegDataError[x, y]\n    ];\n\n \n \n \n \n \n \n \n \nZTest[mu_?NumberQ, sigma_?NumberQ, xbar_?NumberQ, n_?NumberQ, alt_?NumberQ] :=\n    Block[{z, prob, p},\n      z = (xbar - mu) / (sigma / Sqrt[n]);\n      prob = CDF[NormalDistribution[0, 1], z];\n      p = If[alt == 0,\n        If[prob < 1 / 2, 2 * prob, (1 - prob) * 2],\n        If[alt < 0, prob, 1 - prob]];\n      {\"z\" -> z, \"p\" -> p}\n    ];\nZTest[mu_?NumberQ, sigma_?NumberQ, data_?ListQ, freq_, alt_?NumberQ] :=\n    Block[{z, prob, p, xbar, fullData, n, Sx},\n      fullData = ExpandList[data, freq];\n      n = Length[fullData];\n      xbar = Mean[fullData];\n      Sx = StandardDeviation[fullData];\n      Return[Join[ZTest[mu, sigma, xbar, n, alt],\n        {\"meanX\" -> xbar, \"Sx\" -> Sx, \"nItems\" -> n}]]\n    ];\nZTest[mu_?NumberQ, sigma_?NumberQ, data_?ListQ, alt_?NumberQ] :=\n    ZTest[mu, sigma, data, 1, alt];  \n\n(*\none-sample t test\nm0: population mean\nxbar: sample mean\nSx: sample stddev\nn: number of samples\n*)\nTTest[m0_?NumberQ , xbar_?NumberQ, Sx_?NumberQ, n_?NumberQ, alt_?NumberQ] :=\n    Block[{t, a, p, df},\n      df = n - 1;\n      t = (xbar - m0) / ( Sx / Sqrt[n]);\n      a = CDF[StudentTDistribution[df], t];\n      p = If[alt == 0,\n        If[a < 1 / 2, 2 * a, (1 - a) * 2],\n        If[alt < 0, a, 1 - a]];\n      Return[{\"t\" -> t, \"p\" -> p}]\n    ];\nTTest[m0_?NumberQ, data_?ListQ, freq_, alt_?NumberQ] :=\n    Block[{fullData, xbar, n, Sx},\n      fullData = ExpandList[data, freq];\n      xbar = Mean[fullData];\n      n = Length[fullData];\n      Sx = StandardDeviation[fullData];\n      Return[Join[TTest[m0, xbar, Sx, n, alt],\n        {\"meanX\" -> xbar, \"Sx\" -> Sx, \"nItems\" -> n}]]\n    ];\nTTest[m0_?NumberQ, data_?ListQ, alt_?NumberQ] :=\n    TTest[m0, data, 1, alt];   \n\n\n(*2-SampZTest\nsigma1, sigma2: population standard deviation\nxbar1, xbar2: sample mean\nn1, n2: number of sample\nhttps://cran.r-project.org/web/packages/distributions3/vignettes/two-sample-z-test.html\n*)\nTwoSampZTest[sigma1_?NumberQ, sigma2_?NumberQ, xbar1_?NumberQ, n1_?NumberQ, xbar2_, n2_, alt_] :=\n    Block[{z, p, a},\n      z = (xbar1 - xbar2) / (Sqrt[sigma1 ^ 2 / n1 + sigma2^2 / n2]);\n      a = CDF[NormalDistribution[0, 1], z];\n      p = If[alt == 0,\n        If[a < 1 / 2, a * 2, (1 - a) * 2],\n        If[alt < 0, a, 1 - a]];\n      {\"z\" -> z, \"p\" -> p}\n    ];\nTwoSampZTest[sigma1_?NumberQ, sigma2_?NumberQ, data1_?ListQ, data2_?ListQ, freq1_, freq2_, alt_] :=\n    Block[{xbar1, xbar2, n1, n2, Sx1, Sx2, fullData1, fullData2},\n      fullData1 = ExpandList[data1, freq1];\n      fullData2 = ExpandList[data2, freq2];\n      n1 = Length[fullData1];\n      n2 = Length[fullData2];\n      xbar1 = Mean[fullData1];\n      xbar2 = Mean[fullData2];\n      Sx1 = StandardDeviation[fullData1];\n      Sx2 = StandardDeviation[fullData2];\n      Return[Join[TwoSampZTest[sigma1, sigma2, xbar1, n1, xbar2, n2, alt],\n        {\"meanX1\" -> xbar1, \"meanX2\" -> xbar2, \"Sx1\" -> Sx1, \"Sx2\" -> Sx2,\n          \"n1\" -> n1, \"n2\" -> n2}]]\n    ];\nTwoSampZTest[sigma1_?NumberQ, sigma2_?NumberQ, data1_?ListQ, data2_?ListQ, alt_] :=\n    TwoSampZTest[sigma1, sigma2, data1, data2, 1, 1, alt];  \n\n\n(*2-SampTTest (two-sample t test; item 4) tests the equality of the means of two populations\n(m1 and m2) based on independent samples when neither population standard deviation\n(s1 or s2) is known\nxbar1, xbar2: sample mean\nSx1, Sx2: sample standard deviation\nn1, n2: number of samples\nse: use pooled standard error\nReturn:\n  t: t statistic value\n  p: probability of t\n  df: degree of freedom\nhttps://www.statsdirect.co.uk/help/parametric_methods/utt.htm\nhttps://www.cliffsnotes.com/study-guides/statistics/univariate-inferential-tests/\ntwo-sample-t-test-for-comparing-two-means\n*)\nTwoSampTTest[xbar1_?NumberQ, Sx1_?NumberQ, n1_?NumberQ,\n  xbar2_?NumberQ, Sx2_?NumberQ, n2_?NumberQ, alt_?NumberQ, pooled_] :=\n    Block[{t, p, Sp, a, df},\n      df = If[IsTrue[pooled],\n        n1 + n2 - 2,\n        ((Sx1^2 / n1 + Sx2^2 / n2)^2) / (1 / (n1 - 1) * (Sx1^2 / n1)^2 + 1 / (n2 - 1) * (Sx2^2 / n2)^2)\n      ];\n      t = If[IsTrue[pooled],\n        Sp = Sqrt[((n1 - 1) * Sx1 ^ 2 + (n2 - 1) * Sx2 ^ 2) / (n1 + n2 - 2)];\n        (xbar1 - xbar2) / (Sp * Sqrt[1 / n1 + 1 / n2]),\n        (xbar1 - xbar2) / (Sqrt[Sx1 ^2 / n1 + Sx2^2 / n2])\n      ];\n      a = CDF[StudentTDistribution[df], t];\n      p = If[alt == 0,\n        If[a < 1 / 2, a * 2, (1 - a) * 2],\n        If[alt < 0, a, 1 - a]];\n      Return[{\"t\" -> t, \"p\" -> p, \"df\" -> df}]\n    ];\nTwoSampTTest[data1_?ListQ, data2_?ListQ, freq1_, freq2_, alt_, pooled_] :=\n    Block[{xbar1, xbar2, n1, n2, Sx1, Sx2, fullData1, fullData2},\n      fullData1 = ExpandList[data1, freq1];\n      fullData2 = ExpandList[data2, freq2];\n      n1 = Length[fullData1];\n      n2 = Length[fullData2];\n      xbar1 = Mean[fullData1];\n      xbar2 = Mean[fullData2];\n      Sx1 = StandardDeviation[fullData1];\n      Sx2 = StandardDeviation[fullData2];\n      Return[Join[TwoSampTTest[xbar1, Sx1, n1, xbar2, Sx2, n2, alt, pooled],\n        {\"meanX1\" -> xbar1, \"meanX2\" -> xbar2, \"Sx1\" -> Sx1, \"Sx2\" -> Sx2, \"n1\" -> n1, \"n2\" -> n2}]]\n    ];\nTwoSampTTest[data1_?ListQ, data2_?ListQ, alt_, pooled_] :=\n    TwoSampTTest[data1, data2, 1, 1, alt, pooled];   \n\n\n(**\n1-PropZTest (one-proportion z test; item 5) computes a test for an unknown proportion of successes\n(prop). It takes as input the count of successes in the sample x and the count of observations in\nthe sample n.\np0: Null hypothesized value;\nx: Count of successes\nn: Sample size\nop:  Observed proportion\nhttp://tibasicdev.wikidot.com/1-propztest\n**)\nOnePropZTest[p0_, x_, n_, alt_] :=\n    Block[{z, phat, p, np},\n      phat = x / n;\n      np = If[p0 > 1, p0 / 100, p0];\n      z = (phat - np) / Sqrt[np * (1 - np) / n];\n      p = CDF[NormalDistribution[0, 1], z];\n      p = If[alt == 0,\n        If[p < 1 / 2, p * 2, (1 - p) * 2],\n        If[alt < 0, p , 1 - p]\n      ];\n      {\"z\" -> z, \"p\" -> p, \"sProp\" -> phat}\n    ];\n\n(*\n2-PropZTest (two-proportion z test; item 6) computes a test to compare the proportion of successes\n (p1 and p2) from two populations. It takes as input the count of successes in each sample (x1 and x2)\n and the count of observations in each sample (n1 and n2).\n\nhttp://sphweb.bumc.bu.edu/otlt/MPH-Modules/BS/BS704_HypothesisTest-Means-Proportions/\nBS704_HypothesisTest-Means-Proportions_print.html\n\np1: Proportion of success in sample 1\np2: Proportion of success in sample 2\npooledP: Proportion of success in the pooled sample\n*)\nTwoPropZTest[x1_, n1_, x2_, n2_, alt_] :=\n    Block[{z, p, phat1, phat2, phat},\n      phat1 = x1 / n1;\n      phat2 = x2 / n2;\n      phat = (x1 + x2 ) / (n1 + n2);\n      z = (phat1 - phat2 ) / Sqrt[phat * (1 - phat) * (1 / n1 + 1 / n2)];\n      p = CDF[NormalDistribution[0, 1], z];\n      p = If[alt == 0,\n        If[p < 1 / 2, p * 2, (1 - p) * 2],\n        If[alt < 0, p, 1 - p]\n      ];\n      {\"z\" -> z, \"p\" -> p, \"sProp1\" -> phat1,\n        \"sProp2\" -> phat2, \"sProp\" -> phat}\n    ];\n\n(*\nParameters:\n- s: is the population standard deviation\n- m: sample mean\n- n: is the sample size.\n- c: confident level [0...100] or [0..1]\nInternal variables:\n- se: standard error\n- z: is a critical value from the normal distribution\nhttps://www.mathbootcamps.com/calculating-confidence-intervals-for-the-mean/\n*)\nZInterval[sigma_?NumberQ, xbar_?NumberQ, n_, c_] :=\n    Block[{threshold, se, prob},\n      prob = If[c > 1, c / 100, c] / 2 + 1 / 2;\n      threshold = InverseCDF[NormalDistribution[0, 1], prob];\n      se = sigma / Sqrt[n];\n      {{xbar - threshold * se , xbar + threshold * se}}\n    ];\nZInterval[sigma_?NumberQ, data_?ListQ, freq_, c_] :=\n    Block[{fullList, xbar, n, Sx},\n      fullList = ExpandList[data, freq];\n      xbar = Mean[fullList];\n      n = Length[fullList];\n      Sx = StandardDeviation[fullList];\n      Return[Join[ZInterval[sigma, xbar, n, c], {\"meanX\" -> xbar, \"Sx\" -> Sx, \"nItems\" -> n}]]\n    ];\nZInterval[sigma_?NumberQ, data_?ListQ, c_] :=\n    ZInterval[sigma, data, 1, c];\n\n\n(*\nTInterval (one-sample t confidence interval; item 8) computes a confidence interval for an unknown\npopulation mean m when the population standard deviation s is unknown\nxbar: sample mean\nSx: is the sample standard deviation\nn: is the sample size.\nc: confident level [0...100] or [0..1]\n\nInternal variables:\nse: standard error\ndf: degree of freedom\nhttps://www.mathbootcamps.com/calculating-confidence-intervals-for-the-mean/\n*)\nTInterval[xbar_?NumberQ, Sx_, n_, c_] :=\n    Block[{df, threshold, se, prob},\n      df = n - 1;\n      prob = If[c > 1, c / 100, c] / 2 + 1 / 2;\n      threshold = InverseCDF[StudentTDistribution[df], prob];\n      se = Sx / Sqrt[n];\n      {{xbar - threshold * se , xbar + threshold * se}}\n    ];\nTInterval[data_?ListQ, freq_, c_] :=\n    Block[{fullList, xbar, n, Sx},\n      fullList = ExpandList[data, freq];\n      xbar = Mean[fullList];\n      Sx = StandardDeviation[fullList];\n      n = Length[fullList];\n      Return[Join[TInterval[xbar, Sx, n, c], {\"meanX\" -> xbar, \"Sx\" -> Sx, \"nItems\" -> n}]]\n    ];\nTInterval[data_?ListQ, c_] :=\n    TInterval[data, 1, c];\n\n(*\n2-SampZInt (two-sample z confidence interval; item 9) computes a confidence interval for the difference\n between two population means (m1Nm2) when both population standard deviations (s1 and s2) are known.\n  The computed confidence interval depends on the user-specified confidence level.\ns1, s2: population stddev\nm1, m2: sample mean\nc: confident level\nsp: pooled stddev\nse: standard error\n*)\nTwoSampZInt[sigma1_?NumberQ, sigma2_?NumberQ,\n  xbar1_?NumberQ, n1_?NumberQ, xbar2_?NumberQ, n2_?NumberQ, c_] :=\n    Block[{nc, se, z},\n      nc = If[c > 1, c / 100, c] / 2 + 1 / 2;\n      z = InverseCDF[NormalDistribution[0, 1], nc];\n      se = Sqrt[sigma1 ^2 / n1 + sigma2 ^2 / n2];\n      {{(xbar1 - xbar2) - z * se, (xbar1 - xbar2) + z * se}}\n    ];\nTwoSampZInt[sigma1_?NumberQ, sigma2_?NumberQ, data1_?ListQ, data2_?ListQ, freq1_, freq2_, c_] :=\n    Block[{fullData1, fullData2, xbar1, xbar2, n1, n2, Sx1, Sx2},\n      fullData1 = ExpandList[data1, freq1];\n      fullData2 = ExpandList[data2, freq2];\n      xbar1 = Mean[fullData1];\n      xbar2 = Mean[fullData2];\n      n1 = Length[fullData1];\n      n2 = Length[fullData2];\n      Sx1 = StandardDeviation[fullData1];\n      Sx2 = StandardDeviation[fullData2];\n      Return[Join[TwoSampZInt[sigma1, sigma2, xbar1, n1, xbar2, n2, c],\n        {\"meanX1\" -> xbar1, \"meanX2\" -> xbar2, \"Sx1\" -> Sx1, \"Sx2\" -> Sx2, \"n1\" -> n1, \"n2\" -> n2}\n      ]]\n    ];\nTwoSampZInt[sigma1_?NumberQ, sigma2_?NumberQ, data1_?ListQ, data2_?ListQ, c_] :=\n    TwoSampZInt[sigma1, sigma2, data1, data2, 1, 1, c];\n\n(*\nTwo sample T interval\nxbar1, xbar2: sample mean\nSx1, Sx2: sample standard deviation\nn1, n2: number of samples\npooled: use pooled variance\nInternal variables:\n- df: degree of freedom\n- Sp: pooled standard deviation\n- SE: Standard error\nhttp://sphweb.bumc.bu.edu/otlt/MPH-Modules/BS/BS704_Confidence_Intervals/BS704_Confidence_Intervals5.html\n*)\nTwoSampTInt[xbar1_?NumberQ, Sx1_?NumberQ, n1_, xbar2_, Sx2_, n2_, c_, pooled_] :=\n    Block[{nc, df, t, Sp, SE},\n      nc = If[c > 1, c / 100, c] / 2 + 1 / 2;\n      df = If[IsTrue[pooled],\n        n1 + n2 - 2,\n        ((Sx1^2 / n1 + Sx2^2 / n2)^2) / (1 / (n1 - 1) * (Sx1^2 / n1)^2 + 1 / (n2 - 1) * (Sx2^2 / n2)^2)\n      ];\n      SE = If[IsTrue[pooled],\n        Sp = Sqrt[((n1 - 1) * Sx1 ^ 2 + (n2 - 1) * Sx2 ^ 2) / (n1 + n2 - 2)];\n        Sp * Sqrt[1 / n1 + 1 / n2],\n        Sqrt[Sx1 ^2 / n1 + Sx2^2 / n2]];\n      t = InverseCDF[StudentTDistribution[df], nc];\n      {{(xbar1 - xbar2) - t * SE, (xbar1 - xbar2) + t * SE}, \"df\" -> df}\n    ];\nTwoSampTInt[data1_?ListQ, data2_?ListQ, freq1_, freq2_, c_, pooled_] :=\n    Block[{fullData1, fullData2, Sx1, Sx2, n1, n2, xbar1, xbar2},\n      fullData1 = ExpandList[data1, freq1];\n      fullData2 = ExpandList[data2, freq2];\n      Sx1 = StandardDeviation[fullData1];\n      Sx2 = StandardDeviation[fullData2];\n      n1 = Length[fullData1];\n      n2 = Length[fullData2];\n      xbar1 = Mean[fullData1];\n      xbar2 = Mean[fullData2];\n      Return[Join[TwoSampTInt[xbar1, Sx1, n1, xbar2, Sx2, n2, c, pooled],\n        {\"meanX1\" -> xbar1, \"meanX2\" -> xbar2, \"Sx1\" -> Sx1, \"Sx2\" -> Sx2, \"n1\" -> n1, \"n2\" -> n2}\n      ]]\n    ];\nTwoSampTInt[data1_?ListQ, data2_?ListQ, c_, pooled_] :=\n    TwoSampTInt[data1, data2, 1, 1, c, pooled];\n\n(**\n1-PropZInt (one-proportion z confidence interval; item A) computes a confidence interval for an unknown\nproportion of successes. It takes as input the count of successes in the sample x and the count of\nobservations in the sample n.\n\nx: Count of successes\nn: Sample size\npHat: Observed proportion\n**)\nOnePropZInt[x_, n_, c_] :=\n    Block[{threshold, phat, prob, se},\n      prob = If[c > 1, c / 100, c] / 2 + 1 / 2;\n      threshold = InverseCDF[NormalDistribution[0, 1], prob];\n      phat = x / n;\n      se = Sqrt[phat * (1 - phat) / n];\n      {{phat - threshold * se, phat + threshold * se}, \"sProp\" -> phat}\n    ];\n\n(**\n2-Proportion Z confident interval\n2-PropZInt (two-proportion z confidence interval; item B) computes a confidence interval for the\n difference between the proportion of successes in two populations (p1Np2). It takes as input\n  the count of successes in each sample (x1 and x2) and the count of observations in each\n  sample (n1 and n2).\nx: Count of successes\nn: Sample size\npHat: Observed proportion\n**)\nTwoPropZInt[x1_, n1_, x2_, n2_, c_] :=\n    Block[{z, phat1, phat2, nc, se},\n      nc = If[c > 1, c / 100, c] / 2 + 1 / 2;\n      z = InverseCDF[NormalDistribution[0, 1], nc];\n      phat1 = x1 / n1;\n      phat2 = x2 / n2;\n      se = Sqrt[phat1 * (1 - phat1) / n1 + phat2 * (1 - phat2) / n2];\n      {{(phat1 - phat2) - z * se, (phat1 - phat2) + z * se}, \"sProp1\" -> phat1, \"sProp2\" -> phat2}\n    ];\n\n(*\nhttps://www.statisticshowto.datasciencecentral.com/probability-and-statistics/chi-square/\nc2-Test (chi-square test; item C) computes a chi-square test for association on the two-way table of\ncounts in the specified Observed matrix. The null hypothesis H0 for a two-way table is: no\nassociation exists between row variables and column variables. The alternative hypothesis is: the\nvariables are related.\nhttps://towardsdatascience.com/chi-square-test-of-independence-by-hand-e87c0d36e7cd\nhttps://cosmosweb.champlain.edu/people/stevens/WebTech/TIFiles/Chap11-TI-83.pdf\nhttps://www.youtube.com/watch?v=qsIi1JR8Kg4&feature=youtu.be\n*)\nChiSquareTest[observed_, any_] :=\n    Block[{chi2, p, df, expected, sumRow, sumCol, sumAll},\n      AssertMatrixArg[observed];\n       \n       \n      sumRow = Total[observed, {2}];\n       \n      sumCol = Total[observed];\n       \n      sumAll = Total[observed, 2];\n       \n      expected = Partition[Apply[Times, CartesianProduct[sumRow, sumCol], {1}] / sumAll, Length[sumCol]];\n       \n      df = (Dimensions[observed][[1]] - 1) * (Dimensions[observed][[2]] - 1);\n      chi2 = Total[Flatten[(observed - expected) ^ 2 / expected]];\n      p = 1 - CDF[ChiSquareDistribution[df], chi2];\n      {\"chi2\" -> chi2, \"p\" -> p, \"df\" -> df, \"expected\" -> expected}\n    ];\n\n(*\nhttps://www.statisticshowto.datasciencecentral.com/probability-and-statistics/chi-square/\nc2GOF-Test (Chi Square Goodness of Fit; item D) performs a test to confirm that sample data is\nfrom a population that conforms to a specified distribution. For example, c2 GOF can confirm that\nthe sample data came from a normal distribution.\n*)\nChiSquareGOFTest[observed_, expected_, df_] :=\n    Block[{chi2, p, contributions},\n      AssertNotEmptyList[observed];\n      AssertNotEmptyList[expected];\n      AssertSameDimensions[observed, expected];\n      AssertNumberArg[df];\n      chi2 = Total[Flatten[(observed - expected) ^ 2 / expected]];\n      p = 1 - CDF[ChiSquareDistribution[df], chi2];\n      contributions = (observed - expected) ^ 2 / expected;\n      Return[{\"chi2\" -> chi2, \"p\" -> p, \"df\" -> df, \"cntrb\" -> contributions}]\n    ];\n\n(*\nTwoSampFTest\n2-SampFTest (two-sample F-test; item E) computes an F-test to compare two normal population\nstandard deviations (s1 and s2). The population means and standard deviations are all unknown.\n2-SampFTest, which uses the ratio of sample variances Sx12/Sx22, tests the null hypothesis\nH0: s1=s2 against one of the alternatives below.\n\nSx1, Sx2: sample stddev\nn1, n2: sample size\nf: F critical value\nhttp://www.statistics4u.info/fundstat_eng/cc_test_2sample_ftest.html\n*)\nTwoSampFTest[Sx1_?NumberQ, n1_?NumberQ, Sx2_, n2_, alt_] :=\n    Block[{F, p, a},\n      AssertNumberArg[Sx1];\n      AssertNumberArg[Sx2];\n      F = (Sx1 / Sx2) ^2;\n      a = CDF[FRatioDistribution[n1 - 1, n2 - 1], F];\n      p = If[alt == 0,\n        If[a < 1 / 2, a * 2, (1 - a) * 2],\n        If[alt < 0, a, 1 - a]\n      ];\n      {\"FRatio\" -> F, \"p\" -> p}\n    ];\nTwoSampFTest[data1_?ListQ, data2_?ListQ, freq1_, freq2_, alt_] :=\n    Block[{fullData1, fullData2, n1, n2, xbar1, xbar2, Sx1, Sx2},\n      fullData1 = ExpandList[data1, freq1];\n      fullData2 = ExpandList[data2, freq2];\n      n1 = Length[fullData1];\n      n2 = Length[fullData2];\n      xbar1 = Mean[fullData1];\n      xbar2 = Mean[fullData2];\n      Sx1 = StandardDeviation[fullData1];\n      Sx2 = StandardDeviation[fullData2];\n      Return[Join[TwoSampFTest[Sx1, n1, Sx2, n2, alt],\n        {\"Sx1\" -> Sx1, \"Sx2\" -> Sx2, \"meanX1\" -> xbar1, \"meanX2\" -> xbar2, \"n1\" -> n1, \"n2\" -> n2}\n      ]]\n    ];\nTwoSampFTest[data1_?ListQ, data2_?ListQ, alt_] :=\n    TwoSampFTest[data1, data2, 1, 1, alt];\n\n(*http://tibasicdev.wikidot.com/linregttest\n\u03b2 and \u03c1: this line represents the alternative hypothesis. \u03b2 is the true value of the statistic b (it is what we would get if the regression was done on the entire population, rather than a sample); \u03c1 is the true value of the statistic r.\nt is the test statistic, used to calculate p.\np is the probability that we\'d get a correlation this strong by chance, assuming the null hypothesis that there is no actual correlation. When it\'s low, as here, this is evidence against the null hypothesis. Since p<.01, the data is significant on a 1% level, so we reject the null hypothesis and conclude that there is a correlation.\ndf is the degrees of freedom, equal to the number of points minus two\na and b are the parameters of the equation y=a+bx, the regression line we\'ve calculated\ns is the standard error about the line, a measure of the typical size of a residual (the numbers stored in \u221fRESID). It is the square root of the sum of squares of the residuals divided by the degrees of freedom. Smaller values indicate that the points tend to be close to the fitted line, while large values indicate scattering.\nr\u00b2 and r are respectively the coefficients of determination and correlation: a value near 1 or -1 for the former, and near 1 for the latter, indicates a good fit.\n*)\n(*\nLinRegTTest\n y=a+bx\n \u03b2\u22600 and \u03c1\u22600\n t=53.71561274\n p=4.2285344e-8\n df=5\n a=145.3808831\n b=13.09073265\n s=5.913823968\n r\u00b2=.9982701159\n r=.9991346836\n https://www2.isye.gatech.edu/~yxie77/isye2028/lecture12.pdf\n *)\nLinRegTTest[data1_, data2_, freq_, alt_] :=\n    Block[{xList, yList, $n, $b, $a, $r, Sxx, Sxy, Syy, MSE, SE, residual, df, $t, $p, x  },\n      AssertNotEmptyList[data1];\n      AssertNotEmptyList[data2];\n      AssertSameDimensions[data1, data2];\n      xList = ExpandList[data1, freq];\n      yList = ExpandList[data2, freq];\n      AssertNotEmptyList[xList];\n      AssertNotEmptyList[yList];\n      $n = Length[xList];    \n      Sxx = Total[(xList - Mean[xList])^2];\n      Syy = Total[(yList - Mean[yList])^2];\n      Sxy = Total[(yList - Mean[yList]) * (xList - Mean[xList])];\n      $b = Sxy / Sxx;  \n      $a = Mean[yList] - $b * Mean[xList];  \n      $r = Sxy / Sqrt[Sxx * Syy];  \n      residual = yList - ($a + $b * xList);  \n      df = $n - 2;  \n      MSE = Total[residual ^ 2] / df;  \n      $t = $b / Sqrt[MSE / Sxx];  \n      $p = CDF[StudentTDistribution[df], $t];\n      SE = Sqrt[MSE];\n      {\"t\" -> $t, \"p\" -> $p, \"df\" -> df, \"a\" -> $a, \"b\" -> $b, \"stderr\" -> SE, \"r2\" -> $r^2, \"r\" -> $r,\n        \"resid\" -> residual, \"regeq\" -> $a + $b * x}\n    ];\n \nLinRegTTest[data1_, data2_, freq_, alt_, regeq_] := LinRegTTest[data1, data2, freq, alt];\nLinRegTTest[data1_, data2_, alt_] :=\n    LinRegTTest[data1, data2, 1, alt];\n\n(*\nLinRegTInt computes a linear regression T confidence interval for the slope coefficient b. If the\nconfidence interval contains 0, this is insufficient evidence to indicate that the data exhibits\n a linear relationship.\n\nhttp://tibasicdev.wikidot.com/linregtint\n *)\nLinRegTInt[data1_, data2_, freq_, cLevel_] :=\n    Block[{xList, yList, $n, $b, $a, x , $r, prob, Sxx, Sxy, Syy, MSE, SE, residual, df, $p, threshold},\n      AssertNotEmptyList[data1];\n      AssertNotEmptyList[data2];\n      AssertSameDimensions[data1, data2];\n      AssertNumberArg[cLevel];\n\n      xList = ExpandList[data1, freq];\n      yList = ExpandList[data2, freq];\n      AssertNotEmptyList[xList];\n      AssertNotEmptyList[yList];\n      prob = If[cLevel > 1, cLevel / 100, cLevel] / 2 + 1 / 2;\n      $n = Length[xList];    \n      Sxx = Total[(xList - Mean[xList])^2];\n      Syy = Total[(yList - Mean[yList])^2];\n      Sxy = Total[(yList - Mean[yList]) * (xList - Mean[xList])];\n      $b = Sxy / Sxx;  \n      $a = Mean[yList] - $b * Mean[xList];  \n      $r = Sxy / Sqrt[Sxx * Syy];  \n      residual = yList - ($a + $b * xList);  \n      df = $n - 2;  \n      MSE = Total[residual ^ 2] / df;  \n      $p = InverseCDF[StudentTDistribution[df], prob];\n      SE = Sqrt[MSE];\n      threshold = Sqrt[MSE / Sxx];\n      {{$b - $p * threshold, $b + $p * threshold},\n        \"b\" -> $b, \"df\" -> df, \"stderr\" -> SE, \"a\" -> $a, \"r\" -> $r, \"r2\" -> $r^2,\n        \"resid\" -> residual, \"regeq\" -> $a + $b * x}\n    ];\n \nLinRegTInt[data1_, data2_, freq_, cLevel_, regeq_] := LinRegTInt[data1, data2, freq, cLevel];\nLinRegTInt[data1_, data2_, cLevel_] :=\n    LinRegTInt[data1, data2, 1, cLevel];\n\nANOVA[data1_]\n    := ANOVA2[{AssertNotEmptyList[data1]}];\n\nANOVA[data1_, data2_]\n    := ANOVA2[{AssertNotEmptyList[data1], AssertNotEmptyList[data2]}];\n\nANOVA[data1_, data2_, data3_]\n    := ANOVA2[{AssertNotEmptyList[data1], AssertNotEmptyList[data2], AssertNotEmptyList[data3]}];\n\nANOVA[data1_, data2_, data3_, data4_] :=\n    ANOVA2[{AssertNotEmptyList[data1], AssertNotEmptyList[data2], AssertNotEmptyList[data3],\n      AssertNotEmptyList[data4]}];\n\nANOVA[data1_, data2_, data3_, data4_, data5_] :=\n    ANOVA2[{AssertNotEmptyList[data1], AssertNotEmptyList[data2], AssertNotEmptyList[data3],\n      AssertNotEmptyList[data4], AssertNotEmptyList[data5]}];\n\nANOVA[data1_, data2_, data3_, data4_, data5_, data6_] :=\n    ANOVA2[{AssertNotEmptyList[data1], AssertNotEmptyList[data2], AssertNotEmptyList[data3],\n      AssertNotEmptyList[data4], AssertNotEmptyList[data5], AssertNotEmptyList[data6]}];\n\nANOVA2[lists_] :=\n    Block[{ni, factorMS, errorMS, factorSS, $n, xbar, Sxi, xbari, factordf, errordf, errorSS, F, $p, Sxp},\n      ni = Map[Length, lists];  \n      $n = Length[lists];  \n      xbar = Mean[Flatten[lists]];  \n      Sxi = Map[StandardDeviation, lists]; \n      xbari = Map[Mean, lists];  \n      factordf = $n - 1;  \n      errordf = Total[ni - 1];  \n      factorSS = Total[ni * (xbari - xbar)^2];  \n      factorMS = factorSS / factordf;  \n      errorSS = Total[(ni - 1) * Sxi ^ 2];  \n      errorMS = errorSS / errordf;  \n      F = factorMS / errorMS;\n      $p = 1 - CDF[FRatioDistribution[factordf, errordf], F];\n      Sxp = Sqrt[Total[Sxi^2 * (ni - 1)] / Total[ni - 1]];\n      {\"FRatio\" -> F, \"p\" -> $p,\n        \"factordf\" -> factordf, \"factorss\" -> factorSS, \"factorms\" -> factorMS,\n        \"errordf\" -> errordf, \"errorss\" -> errorSS, \"errorms\" -> errorMS, \"Sxp\" -> Sxp}\n    ];\n\nTiValueComparator[x_] :=\n    Block[{tmp},\n      tmp = If[ListQ[x], First[x], x];\n      N[If[NumericQ[Im[tmp]] && Unequal[Im[tmp], 0], Abs[tmp], tmp]]\n    ];\nSortA[x_] :=\n    Block[{},\n      AssertListArg[x];\n      Print[TiValueComparator[x[[1]]]];\n      SortBy[x, TiValueComparator]\n    ];\nSortD[x_] := Reverse[SortA[x]];\n\n \nSortA[x_, y_] :=\n    Block[{},\n      AssertListArg[x];\n      AssertListArg[y];\n      AssertSameDimensions[x, y];\n      SortBy[TiListPoints[x, y], TiValueComparator][[;;, 2]]\n    ];\nSortD[x_, y_] := Reverse[SortA[x, y]];\n\n \n \n \n \n \n \nref[Input_] := Block[{A, imax, tmpR, i, j, m, n, k, h, f},\n  AssertMatrixArg[Input];\n  A = Input;\n   \n   \n  m = Dimensions[A][[1]]; \n  n = Dimensions[A][[2]]; \n\n  h = 1; \n  k = 1; \n  While[h <= m && k <= n,\n     \n    imax = h;\n    For[i = h, i <= m, i = i + 1,\n      If[Abs[A[[imax, k]]] < Abs[A[[i, k]]], imax = i]\n    ];\n     \n    If[PossibleZeroQ[A[[imax, k]]],\n       \n       \n      k = k + 1,\n       \n       \n       \n      tmpR = A[[h]];\n       \n      A = ReplacePart[A, {imax -> A[[h]], h -> A[[imax]]}];\n       \n       \n      For[i = h + 1, i <= m, i = i + 1,\n        f = A[[i, k]] / A[[h, k]];\n         \n         \n        A = ReplacePart[A, {i, k} -> 0]; \n         \n        For[j = k + 1, j <= n, j = j + 1,\n           \n           \n          A = ReplacePart[A, {i, j} -> A[[i, j]] - A[[h, j]] * f];\n           \n           \n        ];\n      ];\n      If[Not[PossibleZeroQ[A[[h, k]]]],\n        A = ReplacePart[A, {h -> A[[h]] / A[[h, k]]}];\n      ];\n      h = h + 1;\n      k = k + 1;\n    ]\n  ];\n  Return[A];\n];\n\n \nClearAll[TiTable];\nTiTable[expr_, sym_, start_, stop_, step_] :=\n    Block[{$tableResult, $tableVal},\n       \n      If[Not[NumberQ[start]], Throw[ErrorStartIsNotANumber]];\n      If[Not[NumberQ[step]], Throw[ErrorStepIsNotANumber]];\n      If[Not[NumberQ[stop]], Throw[ErrorStopIsNotANumber]];\n      If[PossibleZeroQ[step], Throw[ErrorStepIsZero]];\n      If[Sign[stop - start] != Sign[step], Throw[ErrorTableEndless]];\n      Return[Table[expr, {sym, start, stop, step}]]\n    ];\nSetAttributes[TiTable, HoldAllComplete];\nSetAttributes[TiTable, NHoldAll];\nSetAttributes[TiTable, HoldAll];\nSetAttributes[TiTable, Protected];\n\n \n \nTiSeqGetCache[cache_, i_, startOffset_] :=\n    If[i - startOffset + 1 <= 0 || i - startOffset + 1 > Length[cache],\n      Print[\"Error: i - startOffset + 1 <= 0 || i - startOffset + 1 > Length[cache] \", i, \" \", startOffset, \" \", cache];\n      Throw[ErrorDomain],\n      Part[cache, i - startOffset + 1]];\n\n \n \nTiSeqFunc[seqDefFn_, idxArg_, seqMinValues_, cacheValues_] := Block[{idx, $i, initValues, nMin},\n  Print[\"SeqFunc called; fx = \", seqDefFn, \" idxArg = \", idxArg,\n    \" ; seqMinValues = \", seqMinValues, \" | nMin = \", tiSeqNMin];\n  idx = AssertFuzzyIntegerArg[idxArg];\n  nMin = AssertFuzzyIntegerArg[tiSeqNMin];\n  If[TrueQ[nMin < 0], Throw[ErrorDomain]];\n  AssertListArg[cacheValues];\n  If[ListQ[seqMinValues], initValues = seqMinValues, initValues = {seqMinValues}];\n  If[idx < 0 || idx < nMin, Print[\"ErrorDomain idx <= 0 || idx < nMin \", idx, \" \", nMin]; Throw[ErrorDomain]];\n   \n  If[Length[cacheValues] == 0,\n    For[$i = 1, $i <= Length[initValues], $i = $i + 1,\n      AppendTo[cacheValues, Part[initValues, $i] ]\n    ];\n  ];\n\n  For[$i = nMin + Length[cacheValues], $i <= idx, $i = $i + 1,\n    AppendTo[cacheValues, seqDefFn[$i]];\n  ];\n   \n   \n  Return[TiSeqGetCache[cacheValues, idx , nMin]];\n];\nSetAttributes[TiSeqFunc, HoldAll];\nSetAttributes[TiSeqGetCache, HoldFirst];\n"

    invoke-virtual {p0, v0}, Lq/i/b/f/e;->a(Ljava/lang/String;)Lq/i/b/m/b0;

    const-string v0, " \n \n \n \n\n \nPmtEnd = False;\nPmtBegin = True;\n\ncalcRateEff[rate_, isDiscrete_, cf_, pf_] := Block[{},\n  If[isDiscrete,\n    Return[ Power[N[(1 + rate / 100 / cf)], N[cf / pf]] - 1.0]];\n  Return[Exp[N[(rate / 100 / pf)]] - 1];\n];\n\ncalcRate[rateEff_, isDiscrete_, cf_, pf_] := Block[ {},\n  If[isDiscrete, Return[(cf * (Power[N[1 + rateEff], N[pf / cf]] - 1)) * 100]];\n  Return[(Log[Power[N[1 + rateEff], N[pf]]]) * 100];\n];\n\ncalcVars[rate_, nper_, isBeginning_, isDiscrete_, cf_, pf_] := Block[{rateEff, x, a, b},\n  rateEff = calcRateEff[rate, isDiscrete, cf, pf];\n  x = If[TrueQ[isBeginning] || TrueQ[isBeginning == 1], 1 , 0];\n  a = Power[1 + rateEff, N[nper]] - 1;\n  b = (1 + rateEff * x) / rateEff;\n  Return[ { rateEff, x, a, b }];\n];\n\niNewton3[nper_, pmt_, pv_, fv_, isBeginning_, isDiscrete_, cf_, pf_] := Block[\n  {rateEff, $a, $x, np0, dir, iNew, iOld, iCalc, dx, iCalcOld, fi, f1i, $count},\n  AssertNumberArg[nper];\n  AssertNumberArg[pmt];\n  AssertNumberArg[pv];\n  AssertNumberArg[fv];\n  fx[i_, x_] := Power[1.0 + i, N[nper]] * pmt * (1.0 + x * i) - pmt * (1.0 + x * i) + fv * i + pv\n      * i * Power[1.0 + i, N[nper]];\n  f1x[i_, x_] := Block[{$t},\n    $t = 1 + x * i;\n    Return[(Power[1 + i, N[nper]] - 1.0) * (-1.0 * (pmt * $t)) + nper * i * Power[1.0 + i, N[nper - 1.0]]\n        * (pmt * $t + pv * i)];\n  ];\n\n  period[i_, x_] := Block[{b},\n    If[PossibleZeroQ[i],\n      Return[-1.0 * ((pv + fv) / pmt)]\n    ];\n    b = (1.0 + i * x) / i;\n    Return[Log((-1.0 * fv + pmt * b) / (pv + pmt * b)) / Log(1.0 + i)];\n  ];\n\n   \n  If[PossibleZeroQ[(pv + nper * pmt + fv)],\n    Return[0];\n  ];\n\n  Which[pmt * fv <= 0,\n    rateEff = Abs[((nper * pmt + pv - fv) / (nper * pv))],\n\n    pmt * fv > 0,\n    Block[{},\n      If[pv != 0,\n        $a = -1,\n        $a = 1];\n\n      rateEff = Abs[(-1.0 * (fv + $a * nper * pmt)) / (3 * (pmt * Power[nper - 1, 2.0] + pv + fv))];\n    ],\n\n    pv * pmt < 0,\n    rateEff = Abs[((nper * pmt - fv + pv) / (nper * pv))],\n\n    True,\n    Block[{},\n      $a = Abs[pmt / (Abs[pv] + Abs[-1 * fv])];\n      rateEff = $a + 1 / ($a * nper * nper * nper);\n    ]\n  ];\n\n  $x = If[TrueQ[isBeginning] || TrueQ[isBeginning == 1], 1, 0];\n  np0 = period[0, $x];\n  dir = 1;\n\n\n  If[np0 < nper,\n     \n    dir = 1\n  ];\n  If[np0 > nper,\n     \n    dir = -1.0\n  ];\n  If[((dir < 0 && rateEff > 0) || (dir > 0 && rateEff < 0)),\n    rateEff *= -1.0\n  ];\n  If[dir < 0 && rateEff < 0,\n    dir = 1.0;\n    rateEff *= -1.0\n  ];\n\n  iNew = rateEff;\n  iOld = rateEff;\n  iCalc = calcRate[rateEff, isDiscrete, cf, pf];\n  dx;\n  iCalcOld;\n  fi;\n  f1i;\n  $count;\n  For[$count = 1, $count <= 10, $count = $count + 1,\n    Block[{},\n      iOld = iNew;\n\n      fi = fx[iOld, $x];\n      f1i = f1x[iOld, $x];\n      dx = iOld * (fi / f1i);\n      iNew = iOld - dx;\n      fi = fx[iNew, $x];\n\n      iCalc = calcRate[iNew, isDiscrete, cf, pf];\n       \n      iCalcOld = calcRate[iOld, isDiscrete, cf, pf];\n       \n\n      If[iCalc == iCalcOld,\n        Break[]\n      ]\n    ]\n  ];\n\n  Return[iNew];\n];\n\n \nTvmPmt[nper_, rate_, pv_, fv_, pf_, cf_, isBeginning_] := Block[{pmt, vars, rateEff, a, b, x, isDiscrete},\n  AssertNumberArg[nper];\n  AssertNumberArg[rate];\n  AssertNumberArg[pv];\n  AssertNumberArg[fv];\n  AssertNumberArg[pf];\n  AssertNumberArg[cf];\n  isDiscrete = True;\n   \n  vars = calcVars[rate, nper, isBeginning, isDiscrete, cf, pf];\n  { rateEff, x, a, b } = vars;\n\n  If[PossibleZeroQ[rateEff],\n    Return[pmt = -1 * ((fv + pv) / nper)]];\n\n  Return[pmt = -1 * ((fv + pv * (a + 1)) / (a * b))];\n];\n\n \nTvmIR[nper_, pv_, pmt_, fv_, pf_, cf_, isBeginning_] := Block[{isDiscrete, rate, i},\n  AssertNumberArg[nper];\n  AssertNumberArg[pv];\n  AssertNumberArg[pmt];\n  AssertNumberArg[fv];\n  AssertNumberArg[pf];\n  AssertNumberArg[cf];\n  isDiscrete = True;\n   \n\n  i = iNewton3[nper, pmt, pv, fv, isBeginning, isDiscrete, cf, pf];\n  rate = calcRate[i, isDiscrete, cf, pf];\n  Return[rate];\n];\n\n \nTvmPV[nper_, rate_, pmt_, fv_, pf_, cf_, isBeginning_] := Block[{vars, isDiscrete, pv, rateEff, x, a, b},\n  AssertNumberArg[nper];\n  AssertNumberArg[rate];\n  AssertNumberArg[pmt];\n  AssertNumberArg[fv];\n  AssertNumberArg[pf];\n  AssertNumberArg[cf];\n  isDiscrete = True;\n   \n  vars = calcVars[rate, nper, isBeginning, isDiscrete, cf, pf];\n  { rateEff, x, a, b } = vars;\n\n  If[PossibleZeroQ[rateEff],\n    Return[pv = -1 * (fv - nper * pmt)]];\n\n  If[PossibleZeroQ[pmt],\n    Return[pv = -1 * (fv / (a + 1))]];\n\n  Return[pv = -1 * ((fv + a * pmt * b) / (a + 1))];\n];\n\n \nTvmN[rate_, pv_, pmt_, fv_, pf_, cf_, isBeginning_] := Block[{nper, isDiscrete, rateEff, vars, x, a, b},\n  AssertNumberArg[rate];\n  AssertNumberArg[pv];\n  AssertNumberArg[pmt];\n  AssertNumberArg[fv];\n  AssertNumberArg[pf];\n  AssertNumberArg[cf];\n  isDiscrete = True;\n   \n  vars = calcVars[rate, 0, isBeginning, isDiscrete, cf, pf];\n  { rateEff, x, a, b } = vars;\n   \n   \n  Which[\n    PossibleZeroQ[rateEff],\n    nper = -1.0 * ((fv + pv) / pmt),\n\n    PossibleZeroQ[pmt],\n    nper = Log[-1.0 * (fv / pv)] / Log[1.0 + rateEff],\n\n    True,\n    Block[{$t},\n      $t = pv + pmt * b;\n       \n      If[PossibleZeroQ[$t], Throw[ErrorDomain]];\n      If[Not[PossibleZeroQ[$t]], $t = (-1 * fv + pmt * b) / $t];\n      If[Not[PossibleZeroQ[$t]], nper = Log($t) / Log(1 + rateEff)]\n    ]\n  ];\n  Return[nper];\n];\n\n \nTvmFV[nper_, rate_, pv_, pmt_, pf_, cf_, isBeginning_] := Block[{fv, isDiscrete, vars, rateEff, x , a, b},\n  AssertNumberArg[rate];\n  AssertNumberArg[pv];\n  AssertNumberArg[pmt];\n  AssertNumberArg[pv];\n  AssertNumberArg[pf];\n  AssertNumberArg[cf];\n  isDiscrete = True;\n   \n  vars = calcVars[rate, nper, isBeginning, isDiscrete, cf, pf];\n  { rateEff, x, a, b } = vars;\n\n  If[PossibleZeroQ[rateEff],\n    Return[fv = -1 * (pv - nper * pmt)]];\n\n  If[PossibleZeroQ[pmt],\n    Return[fv = -1 * (pv * (1 + a))]];\n\n  Return[fv = -1 * (pv + a * (pv + pmt * b))];\n];\n"

    invoke-virtual {p0, v0}, Lq/i/b/f/e;->a(Ljava/lang/String;)Lq/i/b/m/b0;
    :try_end_0
    .catch Ljava/lang/Exception; {:try_start_0 .. :try_end_0} :catch_0

    return-void

    :catch_0
    move-exception p0

    new-instance v0, Ljava/lang/RuntimeException;

    invoke-direct {v0, p0}, Ljava/lang/RuntimeException;-><init>(Ljava/lang/Throwable;)V

    throw v0
.end method
